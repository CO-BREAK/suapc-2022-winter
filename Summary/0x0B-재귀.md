# 0x00 알고리즘 설명

## 재귀(Recursion)

:하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

### 수학적 귀납법

- 재귀적인 방식으로 푼다 == 귀납적인 방식으로 푼다.

→절차지향적인 사고 탈피!

### 재귀 함수의 조건

- **Base condition**: 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함.
- 모든 입력은 **Base condition**으로 수렴해야 함

### 재귀에 대한 정보 1

- 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함 → 함수의 형태!
- 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
- 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지마 메모리/시간에서는 손해를 봄

### 재귀에 대한 정보 2

- 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있다

```cpp
int fibo(int n){
	if(n<=1) return 1;
	return fibo(n-1)+fibo(n-2);
}
```

### 재귀에 대한 정보 3

- 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨

# 0x02 연습문제

- [ ]  **BOJ 11729: 하노이 탑 이동 순서**

[11729번: 하노이 탑 이동 순서](https://www.acmicpc.net/problem/11729)

1. n-1개의 원판을 기둥 1에서 기둥 2로 옮긴다.
2. n번 원판을 기둥 1에서 기둥 3으로 옮긴다.
3. n-1개의 원판을 기둥 2에서 기둥 3으로 옮긴다.

→원판이 n-1개일 때 옮길 수 있으면 원판이 n개일 때에도 옮길 수 있다.

**[Step by Step]**

1. 함수의 정의
    1. `void func(int n)` 원판 n개를 기둥 1에서 기둥 3으로 옮기는 방법을 출력하는 함수
        1. 이러면 func(n-1)을 활용할 수 없음. 왜냐하면 원판 n개를 기둥 1에서 기둥 3으로 옮기려면 원판 n-1개를 기둥 1에서 기둥 2로 옮겨야 하니까.
    2. `void func(int a, int b, int n)` 원판 n개를 a번 기둥에서 b번 기둥으로 옮기는 방법을 출력하는 함수.
2. Base condition

```cpp
n=1일 때
cout << a << ' ' << b << '\n';
```

1. 재귀 식
    1. n-1개의 원판을 기둥 a에서 기둥 6-a-b로 옮긴다.
    2. n번 원판을 기둥 a에서 기둥 b로 옮긴다.
    3. n-1개의 원판을 기둥 6-a-b에서 기둥 b로 옮긴다.

- [ ]  **BOJ 1074번: Z**

[1074번: Z](https://www.acmicpc.net/problem/1074)

1. 함수의 정의
    1. `int func(int n, int r, int c)` 2^n × 2^n배열에서 (r, c)를 방문하는 순서를 반환하는 함수
2. Base condition
    1. n=0일 때 return 0;
3. 재귀 식
    1. (r,c)가 1번 사각형일 때  `return func(n-1, r, c);`
    2. (r,c)가 2번 사각형일 때  `return half*half + func(n-1, r, c-half);`
    3. (r,c)가 3번 사각형일 때  `return 2*half*half + func(n-1, r-half, c);`
    4. (r,c)가 4번 사각형일 때  `return 3*half*half + func(n-1, r-half, c-half);`
